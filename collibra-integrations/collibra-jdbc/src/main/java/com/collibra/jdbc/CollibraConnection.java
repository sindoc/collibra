package com.collibra.jdbc;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.*;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * JDBC {@link Connection} backed by the Collibra REST API.
 *
 * <p>Authentication is performed lazily on the first statement execution.
 * The driver uses Collibra session cookies (JSESSIONID + X-CSRF-TOKEN) obtained
 * by POSTing to {@code /rest/2.0/auth/sessions}.
 *
 * <p>This connection is read-only â€” Collibra metadata updates should go through
 * the REST API or workflow engine, not SQL DML.
 */
public class CollibraConnection implements Connection {

    private static final Logger log = LoggerFactory.getLogger(CollibraConnection.class);

    private final CollibraConnectionConfig config;
    private final CollibraRestClient       restClient;
    private final AtomicBoolean            closed = new AtomicBoolean(false);

    private boolean autoCommit  = true;
    private boolean readOnly    = true;
    private int     holdability = ResultSet.HOLD_CURSORS_OVER_COMMIT;
    private String  catalog;
    private String  schema;

    CollibraConnection(CollibraConnectionConfig config) throws SQLException {
        this.config     = config;
        this.restClient = new CollibraRestClient(config);
        this.catalog    = config.getDatabase();
        log.debug("CollibraConnection created for {}", config.getBaseUrl());
    }

    @Override
    public Statement createStatement() throws SQLException {
        checkOpen();
        return new CollibraStatement(this, restClient);
    }

    @Override
    public PreparedStatement prepareStatement(String sql) throws SQLException {
        checkOpen();
        return new CollibrapreparedStatement(this, restClient, sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return prepareStatement(sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return prepareStatement(sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        return prepareStatement(sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        return prepareStatement(sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        return prepareStatement(sql);
    }

    @Override
    public DatabaseMetaData getMetaData() throws SQLException {
        checkOpen();
        return new CollibraDatabaseMetaData(this, restClient);
    }

    @Override
    public void close() throws SQLException {
        if (closed.compareAndSet(false, true)) {
            restClient.close();
            log.debug("CollibraConnection closed");
        }
    }

    @Override
    public boolean isClosed() { return closed.get(); }

    @Override
    public boolean isReadOnly() { return readOnly; }

    @Override
    public void setReadOnly(boolean readOnly) throws SQLException {
        if (!readOnly) {
            throw new SQLException("CollibraConnection is always read-only");
        }
    }

    @Override
    public boolean getAutoCommit()              { return autoCommit; }
    @Override
    public void setAutoCommit(boolean ac)       { /* no-op: always auto-commit */ }
    @Override
    public void commit()                        { /* no-op */ }
    @Override
    public void rollback()                      { /* no-op */ }
    @Override
    public void rollback(Savepoint s)           { /* no-op */ }

    @Override
    public String getCatalog()                  { return catalog; }
    @Override
    public void   setCatalog(String catalog)    { this.catalog = catalog; }
    @Override
    public String getSchema()                   { return schema; }
    @Override
    public void   setSchema(String schema)      { this.schema = schema; }

    @Override
    public int getTransactionIsolation()         { return Connection.TRANSACTION_NONE; }
    @Override
    public void setTransactionIsolation(int l)   { /* no-op */ }

    @Override
    public int getHoldability()                  { return holdability; }
    @Override
    public void setHoldability(int h)            { this.holdability = h; }

    @Override
    public Statement createStatement(int t, int c)           throws SQLException { return createStatement(); }
    @Override
    public Statement createStatement(int t, int c, int h)    throws SQLException { return createStatement(); }

    @Override
    public CallableStatement prepareCall(String sql)          throws SQLException {
        throw new SQLFeatureNotSupportedException("prepareCall not supported");
    }
    @Override
    public CallableStatement prepareCall(String sql, int t, int c) throws SQLException {
        throw new SQLFeatureNotSupportedException("prepareCall not supported");
    }
    @Override
    public CallableStatement prepareCall(String sql, int t, int c, int h) throws SQLException {
        throw new SQLFeatureNotSupportedException("prepareCall not supported");
    }

    @Override
    public String nativeSQL(String sql)          { return sql; }
    @Override
    public SQLWarning getWarnings()              { return null; }
    @Override
    public void clearWarnings()                  { /* no-op */ }
    @Override
    public Map<String, Class<?>> getTypeMap()   { return Map.of(); }
    @Override
    public void setTypeMap(Map<String, Class<?>> m) { /* no-op */ }

    @Override
    public Savepoint setSavepoint()              throws SQLException { throw notSupported("setSavepoint"); }
    @Override
    public Savepoint setSavepoint(String name)   throws SQLException { throw notSupported("setSavepoint"); }
    @Override
    public void releaseSavepoint(Savepoint sp)   throws SQLException { throw notSupported("releaseSavepoint"); }

    @Override
    public Clob createClob()                     throws SQLException { throw notSupported("createClob"); }
    @Override
    public Blob createBlob()                     throws SQLException { throw notSupported("createBlob"); }
    @Override
    public NClob createNClob()                   throws SQLException { throw notSupported("createNClob"); }
    @Override
    public SQLXML createSQLXML()                 throws SQLException { throw notSupported("createSQLXML"); }
    @Override
    public Array createArrayOf(String t, Object[] e) throws SQLException { throw notSupported("createArrayOf"); }
    @Override
    public Struct createStruct(String t, Object[] a) throws SQLException { throw notSupported("createStruct"); }

    @Override
    public boolean isValid(int timeout) {
        if (closed.get()) return false;
        try { return restClient.ping(); } catch (Exception e) { return false; }
    }

    @Override
    public void setClientInfo(String name, String value) throws SQLClientInfoException { /* no-op */ }
    @Override
    public void setClientInfo(Properties props)           throws SQLClientInfoException { /* no-op */ }
    @Override
    public String getClientInfo(String name)              { return null; }
    @Override
    public Properties getClientInfo()                     { return new Properties(); }

    @Override
    public void abort(Executor executor) throws SQLException { close(); }
    @Override
    public void setNetworkTimeout(Executor e, int ms)    throws SQLException { /* no-op */ }
    @Override
    public int  getNetworkTimeout()                      { return (int) config.getTimeoutMs(); }

    @Override
    public <T> T unwrap(Class<T> iface)                  throws SQLException {
        if (iface.isInstance(this)) return iface.cast(this);
        throw new SQLException("Not a wrapper for " + iface);
    }
    @Override
    public boolean isWrapperFor(Class<?> iface)          { return iface.isInstance(this); }

    CollibraConnectionConfig getConfig() { return config; }

    private void checkOpen() throws SQLException {
        if (closed.get()) throw new SQLException("Connection is closed");
    }

    private static SQLFeatureNotSupportedException notSupported(String feature) {
        return new SQLFeatureNotSupportedException(feature + " is not supported by CollibraDriver");
    }
}
